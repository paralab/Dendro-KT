<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DENDRO: Member List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DENDRO
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceot.html">ot</a></li><li class="navelem"><a class="el" href="structot_1_1SFC__Tree.html">SFC_Tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ot::SFC_Tree&lt; T, dim &gt; Member List</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the complete list of members for <a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a>, including all inherited members.</p>
<table class="directory">
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a56c22a6c9b60118713df7bb7332bcb06">allgatherSplitters</a>(bool nonempty, const TreeNode&lt; T, dim &gt; &amp;front, MPI_Comm comm, std::vector&lt; int &gt; *activeList=nullptr)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a5ac4095473e2466a5967357080f2d2f5">allgatherSplitters</a>(bool nonempty, const TreeNode&lt; T, dim &gt; &amp;front, const TreeNode&lt; T, dim &gt; &amp;back, MPI_Comm comm, std::vector&lt; int &gt; *activeList=nullptr)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a23cbf4a38ff3c707d311bea0a9658beb">bucketStableAux</a></td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#af47d01dae5d60ade8ff8e5a50da88b31">dist_bcastSplitters</a>(const TreeNode&lt; T, dim &gt; *start, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a33d65dd8a3ba4c815f88477b62d0263f">dist_bcastSplitters</a>(const TreeNode&lt; T, dim &gt; *start, MPI_Comm globalComm, MPI_Comm activeComm, bool isActive, std::vector&lt; int &gt; &amp;activeList)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#adf9441bf9ec13a23512e1896377e39f9">distAdoptAncestors</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ad416b3a32309568db1c85b8d1684506e">distCoalesceSiblings</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#af99696e085e8d6497db63bad49089994">distMinimalBalanced</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, double sfc_tol, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a379b3105f2a1d24574c1b23d1e0c4706">distMinimalBalancedGlobalSort</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, double sfc_tol, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a11b6b19aa4dda19d19cd8e377c8067ac">distMinimalComplete</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, double sfc_tol, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ae6a101fb97b5d6a02b335f5dc0ddf82d">distRemeshSubdomain</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;inTree, const std::vector&lt; OCT_FLAGS::Refine &gt; &amp;refnFlags, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;outTree, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a9faba93954939976649ed382ebce4324">distRemeshWholeDomain</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;inTree, const std::vector&lt; OCT_FLAGS::Refine &gt; &amp;refnFlags, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;outTree, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ae75736521fb0b7845bf537a9688f57fd">distRemoveDuplicates</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, double loadFlexibility, bool strict, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a346b58c1ce90df7ee8267f53b01a0233">distTreeBalancing</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;points, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, RankI maxPtsPerRegion, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a2b98b0d5f51fff6f013d3b2c26ebb31f">distTreeBalancingWithFilter</a>(const ibm::DomainDecider &amp;decider, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;points, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, RankI maxPtsPerRegion, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a70dddc43af9f0d90ef89faad3518c5dc">distTreeConstruction</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;points, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, RankI maxPtsPerRegion, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ab37cf340149233e8b807f88cdd1ba0db">distTreeConstructionWithFilter</a>(const ibm::DomainDecider &amp;decider, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;points, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, RankI maxPtsPerRegion, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a39b6b1be606fbdd5bb3e9ddd686fae1a">distTreeConstructionWithFilter</a>(const ibm::DomainDecider &amp;decider, bool refineAll, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, LevI eLev, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a70e1a675c656b5fba9b2c190bc37369e">distTreePartition</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;points, unsigned int, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#af9f287ae552fc04f1e2fe654c2bb618e">distTreePartition</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;points, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a23d235c2309b246eca66f8ab289ab568">distTreeSort</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;points, double loadFlexibility, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a645d5082642f5c5dd0399a34e5d6e567">firstDescendant</a>(TreeNode&lt; T, dim &gt; &amp;parent, RotI &amp;pRot, LevI descendantLev)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ad8b681a79b51fb06d4c35233cd3d8d55">getContainingBlocks</a>(TreeNode&lt; T, dim &gt; *points, RankI begin, RankI end, const TreeNode&lt; T, dim &gt; *splitters, RankI sBegin, RankI sEnd, LevI lev, SFC_State&lt; dim &gt; sfc, int &amp;numPrevBlocks, const int startSize, std::vector&lt; int &gt; &amp;outBlocks)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ae2fc654a06f165c26fb93aebcb5f1d87">getSurrogateGrid</a>(RemeshPartition remeshPartition, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;oldTree, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;newTree, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a6610785b4bdcfcac2ca650691b231bda">getSurrogateGrid</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;replicateGrid, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;splittersFromGrid, MPI_Comm comm)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a6fd9f7d77c91a6aca006adece877b805">lastDescendant</a>(TreeNode&lt; T, dim &gt; &amp;parent, RotI &amp;pRot, LevI descendantLev)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a567778eecad14a7f2b7e1f7827b38ea0">locCoarsen</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, std::vector&lt; int &gt; &amp;&amp;delta_level)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a78ed52efdcd9241e85932735dd621eb1">locCompleteResolved</a>(const TreeNode&lt; T, dim &gt; *octants, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, RankI begin, RankI end, SFC_State&lt; dim &gt; sfc, TreeNode&lt; T, dim &gt; pNode)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a501b38fcdcf25094c063b39dfe4f2a28">locMatchResolution</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;res)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#af69199005c78f6cc8c65ac104c18b6a2">locMinimalBalanced</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a59acbe564c905468ece872a5aba6eec8">locRefine</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, std::vector&lt; int &gt; &amp;&amp;delta_level)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a69dac7b59b6201f31ed614c66073d875">locRemoveDuplicates</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tnodes)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#aabec9a49db485ddb349970b7a882030d">locRemoveDuplicatesStrict</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tnodes)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a8391016e099bd2816913b67d9a20bb3c">locResolveTree</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;&amp;res)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#abd8505172885e9ea2625fd91273bb993">locTreeBalancing</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;points, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, RankI maxPtsPerRegion)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a273c3514890f7467dcf63eb03a67e64b">locTreeConstruction</a>(TreeNode&lt; T, dim &gt; *points, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, RankI maxPtsPerRegion, RankI begin, RankI end, LevI sLev, LevI eLev, SFC_State&lt; dim &gt; sfc, TreeNode&lt; T, dim &gt; pNode)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a3d7c3d9bbd311e3224dcbb7ceb351175">locTreeConstructionWithFilter</a>(const ibm::DomainDecider &amp;decider, TreeNode&lt; T, dim &gt; *points, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, RankI maxPtsPerRegion, RankI begin, RankI end, LevI sLev, LevI eLev, SFC_State&lt; dim &gt; sfc, TreeNode&lt; T, dim &gt; pNode)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#afe52fca47fccd6274cf79277ebfda435">locTreeConstructionWithFilter</a>(const ibm::DomainDecider &amp;decider, bool refineAll, std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, LevI sLev, LevI eLev, SFC_State&lt; dim &gt; sfc, TreeNode&lt; T, dim &gt; pNode)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a9a4238d83934a941e8009d1a8005e23e">locTreeSort</a>(std::vector&lt; PointType &gt; &amp;points)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">inline</span><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#addf4d1ca978eb99da5a4b56a27a5cdbc">locTreeSort</a>(std::vector&lt; PointType &gt; &amp;points, std::vector&lt; CompanionT &gt; &amp;... companions)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">inline</span><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a5099df83b80d7b8f1de6b5055a100204">locTreeSort</a>(PointType *points, RankI begin, RankI end, LevI sLev, LevI eLev, SFC_State&lt; dim &gt; sfc)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a5797f39ff5d0713713d04552b595ab78">locTreeSort</a>(PointType *points, RankI begin, RankI end, LevI sLev, LevI eLev, SFC_State&lt; dim &gt; sfc, KeyFun keyfun, Companion *... companions)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a528f0c412def791d9b787f7124924b39">locTreeSortInUnitCube</a>(std::vector&lt; PointType &gt; &amp;points)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">inline</span><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#abf8a351dae76d0ec6645a2b852806acc">locTreeSortMaxDepth</a>(std::vector&lt; PointType &gt; &amp;points)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">inline</span><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a0a94bb5dfbe70aaa998c045ee8cb25ff">locTreeSortMaxDepth</a>(std::vector&lt; PointType &gt; &amp;points, std::vector&lt; CompanionT &gt; &amp;... companions)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">inline</span><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a96bd8eadc07830ee4a5f19eaa905468a">lower_bound</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedOcts, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedKeys)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a6ed7f5b6717f4ef97339d2c726d8c0f1">propagateNeighbours</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a14b74735003d4f4efda39f4a00607aa1">removeDescendants</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedOcts, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedKeys)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ab266d30b716253357fe79653d9de5020">removeEqual</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedOcts, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedKeys)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a819ec7ee91bf6862ac5deb14047ec890">retainDescendants</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedOcts, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedKeys)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#aeda3f3cd94e7af5794de6cad77d53308">RM_DUPS_AND_ANC</a></td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a4560e2e8ccd0b503a6d65f9a2abc8f8b">RM_DUPS_ONLY</a></td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ad761b3a136f676ef96cdba73e88689ba">SFC_bucketing</a>(TreeNode&lt; T, dim &gt; *points, RankI begin, RankI end, LevI lev, SFC_State&lt; dim &gt; sfc, std::array&lt; RankI, 1+nchild(dim)&gt; &amp;outSplitters, RankI &amp;outAncStart, RankI &amp;outAncEnd)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a604f8a6631011e3f18b6d96323d13c38">SFC_bucketing_general</a>(PointType *points, RankI begin, RankI end, LevI lev, SFC_State&lt; dim &gt; sfc, KeyFun keyfun, bool separateAncestors, bool ancestorsFirst, std::array&lt; RankI, 1+nchild(dim)&gt; &amp;outSplitters, RankI &amp;outAncStart, RankI &amp;outAncEnd, Companion *... companions)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a40a58d363d64e5926cf38a638f4ea9c9">SFC_bucketing_impl</a>(PointType *points, RankI begin, RankI end, LevI lev, SFC_State&lt; dim &gt; sfc, KeyFun keyfun, bool separateAncestors, bool ancestorsFirst, std::array&lt; RankI, 1+nchild(dim)&gt; &amp;outSplitters, RankI &amp;outAncStart, RankI &amp;outAncEnd)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a34335f5599ff608a1585cf8cd5a3da2a">SFC_bucketStable</a>(const PointType *points, RankI begin, RankI end, LevI lev, KeyFun keyfun, bool separateAncestors, std::array&lt; RankI, nchild(dim)+1 &gt; offsets, const std::array&lt; RankI, nchild(dim)+1 &gt; &amp;bucketEnds, ValueType *values)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#add86cfc1c537107ab86bdd077c020bc0">SFC_bucketStable</a>(const PointType *points, RankI begin, RankI end, LevI lev, KeyFun keyfun, bool separateAncestors, const std::array&lt; RankI, nchild(dim)+1 &gt; &amp;offsets, const std::array&lt; RankI, nchild(dim)+1 &gt; &amp;bucketEnds, CompanionHead *companionHead, CompanionTail *... companionTail)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a587917aa3af350a0a5784915c7f3316f">SFC_locateBuckets</a>(const TreeNode&lt; T, dim &gt; *points, RankI begin, RankI end, LevI lev, SFC_State&lt; dim &gt; sfc, std::array&lt; RankI, 1+nchild(dim)&gt; &amp;outSplitters, RankI &amp;outAncStart, RankI &amp;outAncEnd)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#adf1959ad782e3ef6a123db54c3a71a0e">SFC_locateBuckets_impl</a>(const PointType *points, RankI begin, RankI end, LevI lev, SFC_State&lt; dim &gt; sfc, KeyFun keyfun, bool separateAncestors, bool ancestorsFirst, std::array&lt; RankI, 1+nchild(dim)&gt; &amp;outSplitters, RankI &amp;outAncStart, RankI &amp;outAncEnd)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a810322adf26394f4c80dfcec821286b9">splitParents</a>(std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a4c282f2905438c2d8a56f1f0181f8319">treeNode2PartitionRank</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;treeNodes, const PartitionFront&lt; T, dim &gt; &amp;partitionSplitters)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a0ccca509ae316edfecaf6e02b901b081">treeNode2PartitionRank</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;treeNodes, const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;partitionFrontSplitters)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#acd7e2a620ff6b55624d6c04c7dfa75a6">treeNode2PartitionRanks</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;treeNodes, const PartitionFrontBack&lt; T, dim &gt; &amp;partitionSplitters, const std::vector&lt; int &gt; *active)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#ac4f6127ce571f667568b412e5d2c9bdf">tsearch_equal_range</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedOcts, const TreeNode&lt; T, dim &gt; &amp;key)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a9954ddc4af7929438b991e13ee75eaa5">tsearch_equal_range</a>(const TreeNode&lt; T, dim &gt; *sortedOcts, const TreeNode&lt; T, dim &gt; &amp;key, size_t begin, size_t end, LevI sLev, SFC_State&lt; dim &gt; sfc)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a2745e627dabb8f6ff32c59955caaa4f9">tsearch_lower_bound</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedOcts, const TreeNode&lt; T, dim &gt; &amp;key)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr class="even"><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#aa4e390b88c9325ed72eaba418b8d6167">tsearch_upper_bound</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;sortedOcts, const TreeNode&lt; T, dim &gt; &amp;key)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
  <tr><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html#a315a7240123ff32e0e3a24fe0b737fd6">unstableOctants</a>(const std::vector&lt; TreeNode&lt; T, dim &gt;&gt; &amp;tree, const bool dangerLeft=true, const bool dangerRight=true)</td><td class="entry"><a class="el" href="structot_1_1SFC__Tree.html">ot::SFC_Tree&lt; T, dim &gt;</a></td><td class="entry"><span class="mlabel">static</span></td></tr>
</table></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
