<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DENDRO: par Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DENDRO
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">par Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Collection of Generic Parallel Functions: Sorting, Partitioning, Searching,...  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_1_1KwayBlocks.html">KwayBlocks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_1_1KwayComms.html">KwayComms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpar_1_1MinMeanMax.html">MinMeanMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_1_1Mpi__datatype.html">Mpi_datatype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class used for communicating messages using user-defined datatypes. The user must implement the static member function "value()" that returns the MPI_Datatype corresponding to this user-defined datatype.  <a href="classpar_1_1Mpi__datatype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_1_1Mpi__datatype_3_01bool_01_4.html">Mpi_datatype&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization of the abstract class <a class="el" href="classpar_1_1Mpi__datatype.html" title="An abstract class used for communicating messages using user-defined datatypes. The user must impleme...">Mpi_datatype</a>. This can be used for communicating messages of type "bool".  <a href="classpar_1_1Mpi__datatype_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_1_1Mpi__datatype_3_01ot_1_1OctreeAdler32_01_4.html">Mpi_datatype&lt; ot::OctreeAdler32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_1_1Mpi__datatype_3_01ot_1_1TNPoint_3_01T_00_01dim_01_4_01_4.html">Mpi_datatype&lt; ot::TNPoint&lt; T, dim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization of the abstract class "Mpi_datatype" for communicating messages of type "ot::TNPoint".  <a href="classpar_1_1Mpi__datatype_3_01ot_1_1TNPoint_3_01T_00_01dim_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_1_1Mpi__datatype_3_01ot_1_1TreeNode_3_01T_00_01dim_01_4_01_4.html">Mpi_datatype&lt; ot::TreeNode&lt; T, dim &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization of the abstract class "Mpi_datatype" for communicating messages of type "ot::TreeNode".  <a href="classpar_1_1Mpi__datatype_3_01ot_1_1TreeNode_3_01T_00_01dim_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpar_1_1Mpi__datatype_3_01std_1_1complex_3_01T_01_4_01_4.html">Mpi_datatype&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpar_1_1P2PMeta.html">P2PMeta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpar_1_1P2PPartners.html">P2PPartners</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpar_1_1P2PRequest.html">P2PRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpar_1_1P2PScalar.html">P2PScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpar_1_1P2PVector.html">P2PVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpar_1_1SendRecvSchedule.html">SendRecvSchedule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a41724fba006b22060f83b15d96e81e5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41724fba006b22060f83b15d96e81e5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a41724fba006b22060f83b15d96e81e5b">bitonicSort</a> (std::vector&lt; T &gt; &amp;in, MPI_Comm comm)</td></tr>
<tr class="memdesc:a41724fba006b22060f83b15d96e81e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of parallel bitonic sort that does not expect the number of processors to be a power of 2. In fact, the number of processors can even be odd. Moreover, we do not even expect the length of the vector (neither locally nor globally) to be a power of 2 or even. Moreover, each processor can call this with a different number of elements. However, we do expect that 'in' atleast has 1 element on each processor. This recursively calls the function bitonicSort_binary, followed by a special parallel merge.  <a href="#a41724fba006b22060f83b15d96e81e5b">More...</a><br /></td></tr>
<tr class="separator:a41724fba006b22060f83b15d96e81e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3992a13172d29616c6d877d283178c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e3992a13172d29616c6d877d283178c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a0e3992a13172d29616c6d877d283178c">bitonicSort_binary</a> (std::vector&lt; T &gt; &amp;in, MPI_Comm comm)</td></tr>
<tr class="memdesc:a0e3992a13172d29616c6d877d283178c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of parallel bitonic sort that expects the number of processors to be a power of 2. However, unlike most implementations, we do not expect the length of the vector (neither locally nor globally) to be a power of 2 or even. Moreover, each processor can call this with a different number of elements. However, we do expect that 'in' atleast has 1 element on each processor.  <a href="#a0e3992a13172d29616c6d877d283178c">More...</a><br /></td></tr>
<tr class="separator:a0e3992a13172d29616c6d877d283178c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9704922999ccde4fbc76e7ee92d2df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba9704922999ccde4fbc76e7ee92d2df"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#aba9704922999ccde4fbc76e7ee92d2df">concatenate</a> (std::vector&lt; T &gt; &amp;listA, std::vector&lt; T &gt; &amp;listB, MPI_Comm comm)</td></tr>
<tr class="memdesc:aba9704922999ccde4fbc76e7ee92d2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel concatenation function. listB is appended (globally) to listA and the result is stored in listA. An useful application of this function is when listA and listB are individually sorted (globally) and the smallest element in listB is greater than the largest element in listA and we want to create a merged list that is sorted.  <a href="#aba9704922999ccde4fbc76e7ee92d2df">More...</a><br /></td></tr>
<tr class="separator:aba9704922999ccde4fbc76e7ee92d2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cda730c20b5d40e582d81d5dd65ddb2"><td class="memTemplParams" colspan="2">template&lt;class TN &gt; </td></tr>
<tr class="memitem:a8cda730c20b5d40e582d81d5dd65ddb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a8cda730c20b5d40e582d81d5dd65ddb2">dbg_printTNList</a> (const TN *tnList, unsigned int listSz, unsigned int lev, MPI_Comm comm)</td></tr>
<tr class="memdesc:a8cda730c20b5d40e582d81d5dd65ddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a distributed list of treeNodes.  <a href="#a8cda730c20b5d40e582d81d5dd65ddb2">More...</a><br /></td></tr>
<tr class="separator:a8cda730c20b5d40e582d81d5dd65ddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82194ab32047be2e560e1fbcc8e76f82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82194ab32047be2e560e1fbcc8e76f82"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a82194ab32047be2e560e1fbcc8e76f82">defaultWeight</a> (const T *a)</td></tr>
<tr class="separator:a82194ab32047be2e560e1fbcc8e76f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e333399b7d956471926c9fad721ad73"><td class="memTemplParams" colspan="2">template&lt;typename WeightT &gt; </td></tr>
<tr class="memitem:a7e333399b7d956471926c9fad721ad73"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a7e333399b7d956471926c9fad721ad73">loadImbalance</a> (WeightT localWeight, MPI_Comm comm)</td></tr>
<tr class="separator:a7e333399b7d956471926c9fad721ad73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9131e559b4020008f287cd0674c8904b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9131e559b4020008f287cd0674c8904b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a9131e559b4020008f287cd0674c8904b">maxLowerBound</a> (const std::vector&lt; T &gt; &amp;keys, const std::vector&lt; T &gt; &amp;searchList, std::vector&lt; T &gt; &amp;results, MPI_Comm comm)</td></tr>
<tr class="memdesc:a9131e559b4020008f287cd0674c8904b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel search function.  <a href="#a9131e559b4020008f287cd0674c8904b">More...</a><br /></td></tr>
<tr class="separator:a9131e559b4020008f287cd0674c8904b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b8391c3ddda3ceea327c8f4df32b0e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3b8391c3ddda3ceea327c8f4df32b0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ae3b8391c3ddda3ceea327c8f4df32b0e">MergeLists</a> (std::vector&lt; T &gt; &amp;listA, std::vector&lt; T &gt; &amp;listB, int KEEP_WHAT)</td></tr>
<tr class="memdesc:ae3b8391c3ddda3ceea327c8f4df32b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges lists A, and B, retaining either the low or the High in list A.  <a href="#ae3b8391c3ddda3ceea327c8f4df32b0e">More...</a><br /></td></tr>
<tr class="separator:ae3b8391c3ddda3ceea327c8f4df32b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad721e799fda8d9b03f005c82dfd907"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abad721e799fda8d9b03f005c82dfd907"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#abad721e799fda8d9b03f005c82dfd907">MergeSplit</a> (std::vector&lt; T &gt; &amp;local_list, int which_keys, int partner, MPI_Comm comm)</td></tr>
<tr class="memdesc:abad721e799fda8d9b03f005c82dfd907"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main operation in the parallel bitonic sort algorithm. This implements the compare-split operation.  <a href="#abad721e799fda8d9b03f005c82dfd907">More...</a><br /></td></tr>
<tr class="separator:abad721e799fda8d9b03f005c82dfd907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f912a1ec8cfe795a15bfd1eb0f17aea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f912a1ec8cfe795a15bfd1eb0f17aea"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a3f912a1ec8cfe795a15bfd1eb0f17aea">Mpi_Allgather</a> (const T *sendbuf, T *recvbuf, int count, MPI_Comm comm)</td></tr>
<tr class="separator:a3f912a1ec8cfe795a15bfd1eb0f17aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507451ffddae0c35a435a482ee90e2b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a507451ffddae0c35a435a482ee90e2b9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a507451ffddae0c35a435a482ee90e2b9">Mpi_Allgatherv</a> (const T *sendbuf, int sendcount, T *recvbuf, int *recvcounts, int *displs, MPI_Comm comm)</td></tr>
<tr class="separator:a507451ffddae0c35a435a482ee90e2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f36f5f0f402192cafe7abd2e79e2cc2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f36f5f0f402192cafe7abd2e79e2cc2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a6f36f5f0f402192cafe7abd2e79e2cc2">Mpi_Allreduce</a> (const T *sendbuf, T *recvbuf, int count, MPI_Op op, MPI_Comm comm)</td></tr>
<tr class="separator:a6f36f5f0f402192cafe7abd2e79e2cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4031931ac4952c894915988f03fae856"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4031931ac4952c894915988f03fae856"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpar_1_1MinMeanMax.html">MinMeanMax</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a4031931ac4952c894915988f03fae856">Mpi_AllreduceMinMeanMax</a> (T localData, MPI_Comm comm)</td></tr>
<tr class="separator:a4031931ac4952c894915988f03fae856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16250c7602442c07706b8fb34498b3b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16250c7602442c07706b8fb34498b3b7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a16250c7602442c07706b8fb34498b3b7">Mpi_Alltoall</a> (const T *sendbuf, T *recvbuf, int count, MPI_Comm comm)</td></tr>
<tr class="separator:a16250c7602442c07706b8fb34498b3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf98403458c01596773f87f1624340c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf98403458c01596773f87f1624340c7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#acf98403458c01596773f87f1624340c7">Mpi_Alltoallv_dense</a> (const T *sendbuf, int *sendcnts, int *sdispls, T *recvbuf, int *recvcnts, int *rdispls, MPI_Comm comm)</td></tr>
<tr class="separator:acf98403458c01596773f87f1624340c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a9666e020c2834f893b1a74e924853"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4a9666e020c2834f893b1a74e924853"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#af4a9666e020c2834f893b1a74e924853">Mpi_Alltoallv_Kway</a> (const T *sbuff_, int *s_cnt_, int *sdisp_, T *rbuff_, int *r_cnt_, int *rdisp_, MPI_Comm c)</td></tr>
<tr class="separator:af4a9666e020c2834f893b1a74e924853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e372a8c8f3327c9bd0c9bb57a4ecbb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e372a8c8f3327c9bd0c9bb57a4ecbb8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a0e372a8c8f3327c9bd0c9bb57a4ecbb8">Mpi_Alltoallv_sparse</a> (const T *sendbuf, int *sendcnts, int *sdispls, T *recvbuf, int *recvcnts, int *rdispls, MPI_Comm comm)</td></tr>
<tr class="separator:a0e372a8c8f3327c9bd0c9bb57a4ecbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678d79b3e398b5c7a57ff433d5fe134d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a678d79b3e398b5c7a57ff433d5fe134d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a678d79b3e398b5c7a57ff433d5fe134d">mpi_and</a> (const T t_, MPI_Comm comm)</td></tr>
<tr class="separator:a678d79b3e398b5c7a57ff433d5fe134d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07e7526826fd6076368389596162ce5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac07e7526826fd6076368389596162ce5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ac07e7526826fd6076368389596162ce5">Mpi_Bcast</a> (T *buffer, int count, int root, MPI_Comm comm)</td></tr>
<tr class="separator:ac07e7526826fd6076368389596162ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665c131431ad9b6bf575964bd0d1e0cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#a665c131431ad9b6bf575964bd0d1e0cb">mpi_comm_rank</a> (MPI_Comm comm)</td></tr>
<tr class="separator:a665c131431ad9b6bf575964bd0d1e0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6f2d8ab68d4aa4a5297b76bdd888a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#acc6f2d8ab68d4aa4a5297b76bdd888a1">mpi_comm_size</a> (MPI_Comm comm)</td></tr>
<tr class="separator:acc6f2d8ab68d4aa4a5297b76bdd888a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf969002e58145bf248fdb2c39ce2611"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf969002e58145bf248fdb2c39ce2611"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#abf969002e58145bf248fdb2c39ce2611">Mpi_Exscan</a> (const T *sendbuf, T *recvbuf, int count, MPI_Op op, MPI_Comm comm)</td></tr>
<tr class="separator:abf969002e58145bf248fdb2c39ce2611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab353e117ed61668e26eee1f171867833"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab353e117ed61668e26eee1f171867833"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ab353e117ed61668e26eee1f171867833">Mpi_Gather</a> (const T *sendBuffer, T *recvBuffer, int count, int root, MPI_Comm comm)</td></tr>
<tr class="separator:ab353e117ed61668e26eee1f171867833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7d08734a05f1c5f64fb39d9d394963"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e7d08734a05f1c5f64fb39d9d394963"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a3e7d08734a05f1c5f64fb39d9d394963">Mpi_Iallgather</a> (const T *sendbuf, T *recvbuf, int count, MPI_Comm comm, MPI_Request *request)</td></tr>
<tr class="separator:a3e7d08734a05f1c5f64fb39d9d394963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98437044ff27973fd3e52a3a78cbb971"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98437044ff27973fd3e52a3a78cbb971"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a98437044ff27973fd3e52a3a78cbb971">Mpi_Imrecv</a> (T *buf, int count, MPI_Message *message, MPI_Request *request)</td></tr>
<tr class="separator:a98437044ff27973fd3e52a3a78cbb971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5323d9cac38e61044e1cca337400e683"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5323d9cac38e61044e1cca337400e683"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a5323d9cac38e61044e1cca337400e683">Mpi_Irecv</a> (T *buf, int count, int source, int tag, MPI_Comm comm, MPI_Request *request)</td></tr>
<tr class="separator:a5323d9cac38e61044e1cca337400e683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3973b507fce9b48f74acec8f40767bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3973b507fce9b48f74acec8f40767bb"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#aa3973b507fce9b48f74acec8f40767bb">Mpi_Isend</a> (const T *buf, int count, int dest, int tag, MPI_Comm comm, MPI_Request *request)</td></tr>
<tr class="separator:aa3973b507fce9b48f74acec8f40767bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31372a4e3b8df9afddf2e423a367b9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab31372a4e3b8df9afddf2e423a367b9c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ab31372a4e3b8df9afddf2e423a367b9c">Mpi_Issend</a> (const T *buf, int count, int dest, int tag, MPI_Comm comm, MPI_Request *request)</td></tr>
<tr class="separator:ab31372a4e3b8df9afddf2e423a367b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a2e5f9178eada3ec45f3eb8603abe7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11a2e5f9178eada3ec45f3eb8603abe7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a11a2e5f9178eada3ec45f3eb8603abe7">mpi_max</a> (const T t, MPI_Comm comm)</td></tr>
<tr class="separator:a11a2e5f9178eada3ec45f3eb8603abe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f89f090934876e7226b7cc29f66dbe1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f89f090934876e7226b7cc29f66dbe1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a4f89f090934876e7226b7cc29f66dbe1">mpi_min</a> (const T t, MPI_Comm comm)</td></tr>
<tr class="separator:a4f89f090934876e7226b7cc29f66dbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5c0c242ec0d019eb00df530d845ec7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b5c0c242ec0d019eb00df530d845ec7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a7b5c0c242ec0d019eb00df530d845ec7">Mpi_Mrecv</a> (T *buf, int count, MPI_Message *message, MPI_Status *status)</td></tr>
<tr class="separator:a7b5c0c242ec0d019eb00df530d845ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e56743243a5b6ef54e73b4f8a0e7f02"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e56743243a5b6ef54e73b4f8a0e7f02"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a1e56743243a5b6ef54e73b4f8a0e7f02">Mpi_NBX</a> (const int *destinations, const int ndest, const T *sendbuf, const int count, std::vector&lt; int &gt; &amp;sources, std::vector&lt; T &gt; &amp;recvbuf, MPI_Comm comm, bool sort_sources=true)</td></tr>
<tr class="memdesc:a1e56743243a5b6ef54e73b4f8a0e7f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonblocking Consensus due to (Hoefler et al., 2010).  <a href="#a1e56743243a5b6ef54e73b4f8a0e7f02">More...</a><br /></td></tr>
<tr class="separator:a1e56743243a5b6ef54e73b4f8a0e7f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9553e0613b4aebf96a2665a8446ae945"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9553e0613b4aebf96a2665a8446ae945"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a9553e0613b4aebf96a2665a8446ae945">Mpi_NBX</a> (const int *destinations, const int ndest, const T *sendbuf, const int count, std::vector&lt; int &gt; &amp;sources, std::vector&lt; T &gt; &amp;recvbuf, MPI_Comm comm, <a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a> synch_p2p, <a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a> synch_global, bool sort_sources=true)</td></tr>
<tr class="separator:a9553e0613b4aebf96a2665a8446ae945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99b29e94b39dcf1f38a93c1eaed2187"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#ad99b29e94b39dcf1f38a93c1eaed2187">Mpi_NBX_neighbors</a> (const int *destinations, const int ndest, std::vector&lt; int &gt; &amp;sources, MPI_Comm comm, bool sort_sources=true)</td></tr>
<tr class="memdesc:ad99b29e94b39dcf1f38a93c1eaed2187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonblocking Consensus due to (Hoefler et al., 2010). Allows sparse alltoall exchange without calling any alltoall. A barrier is automatically called for correctness. For better control over when the barrier must complete, supply MPI_Request(s) to the appropriate overloads.  <a href="#ad99b29e94b39dcf1f38a93c1eaed2187">More...</a><br /></td></tr>
<tr class="separator:ad99b29e94b39dcf1f38a93c1eaed2187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21210a95971718fe1711c62fc8fb803a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#a21210a95971718fe1711c62fc8fb803a">Mpi_NBX_neighbors</a> (const int *destinations, const int ndest, std::vector&lt; int &gt; &amp;sources, MPI_Comm comm, <a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a> synch_p2p, <a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a> synch_global, bool sort_sources=true)</td></tr>
<tr class="memdesc:a21210a95971718fe1711c62fc8fb803a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonblocking Consensus due to (Hoefler et al., 2010). Allows sparse alltoall exchange without calling any alltoall. However, a non-blocking synch is needed before sending again, due to implementation of nbx with MPI_ANY_SOURCE. Must call MPI_Waitall() with synch_p2p[] before sending to destinations. Must call MPI_Wait() with synch_global before sending to others. After synch_global completes, synch_p2p[] is not needed, so synch_p2p=nullptr is ok if no middle phase for destinations only.  <a href="#a21210a95971718fe1711c62fc8fb803a">More...</a><br /></td></tr>
<tr class="separator:a21210a95971718fe1711c62fc8fb803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affec3e38b8dbe9de3614e84eba6d6875"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#affec3e38b8dbe9de3614e84eba6d6875">Mpi_NBX_sizes</a> (const int *destinations, const int *send_sizes, const int ndest, std::vector&lt; int &gt; &amp;sources, std::vector&lt; int &gt; &amp;recv_sizes, MPI_Comm comm, bool sort_sources=true)</td></tr>
<tr class="memdesc:affec3e38b8dbe9de3614e84eba6d6875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonblocking Consensus due to (Hoefler et al., 2010).  <a href="#affec3e38b8dbe9de3614e84eba6d6875">More...</a><br /></td></tr>
<tr class="separator:affec3e38b8dbe9de3614e84eba6d6875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d93ad609b8664db3eb1b837c9377d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#a69d93ad609b8664db3eb1b837c9377d2">Mpi_NBX_sizes</a> (const int *destinations, const int *send_sizes, const int ndest, std::vector&lt; int &gt; &amp;sources, std::vector&lt; int &gt; &amp;recv_sizes, MPI_Comm comm, <a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a> synch_p2p, <a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a> synch_global, bool sort_sources=true)</td></tr>
<tr class="separator:a69d93ad609b8664db3eb1b837c9377d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd77f62a8e69686746a0881deeb58f50"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#abd77f62a8e69686746a0881deeb58f50">mpi_next_if</a> (bool included, MPI_Comm comm)</td></tr>
<tr class="memdesc:abd77f62a8e69686746a0881deeb58f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ranks of nonempty predecessor and successor without comm split.  <a href="#abd77f62a8e69686746a0881deeb58f50">More...</a><br /></td></tr>
<tr class="separator:abd77f62a8e69686746a0881deeb58f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e4851a298231bc0f8a9f0c8e6aa615"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82e4851a298231bc0f8a9f0c8e6aa615"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a82e4851a298231bc0f8a9f0c8e6aa615">mpi_or</a> (const T t_, MPI_Comm comm)</td></tr>
<tr class="separator:a82e4851a298231bc0f8a9f0c8e6aa615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27df4c5d5f15c007e2cf7a6cad6a9c37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27df4c5d5f15c007e2cf7a6cad6a9c37"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a27df4c5d5f15c007e2cf7a6cad6a9c37">Mpi_Recv</a> (T *buf, int count, int source, int tag, MPI_Comm comm, MPI_Status *status)</td></tr>
<tr class="separator:a27df4c5d5f15c007e2cf7a6cad6a9c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5e460961f44d284ec870ea19c88766"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a5e460961f44d284ec870ea19c88766"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a8a5e460961f44d284ec870ea19c88766">Mpi_Reduce</a> (const T *sendbuf, T *recvbuf, int count, MPI_Op op, int root, MPI_Comm comm)</td></tr>
<tr class="separator:a8a5e460961f44d284ec870ea19c88766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19fcde5a62c75d7a63d3b631301ddcd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac19fcde5a62c75d7a63d3b631301ddcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpar_1_1MinMeanMax.html">MinMeanMax</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ac19fcde5a62c75d7a63d3b631301ddcd">Mpi_ReduceMinMeanMax</a> (T localData, MPI_Comm comm)</td></tr>
<tr class="separator:ac19fcde5a62c75d7a63d3b631301ddcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7394dbde57f4738b4f903f3469cd074"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7394dbde57f4738b4f903f3469cd074"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ae7394dbde57f4738b4f903f3469cd074">Mpi_Scan</a> (const T *sendbuf, T *recvbuf, int count, MPI_Op op, MPI_Comm comm)</td></tr>
<tr class="separator:ae7394dbde57f4738b4f903f3469cd074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9560aba78fafcbed70d9c7a87426521c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a9560aba78fafcbed70d9c7a87426521c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a9560aba78fafcbed70d9c7a87426521c">Mpi_Sendrecv</a> (const T *sendBuf, int sendCount, int dest, int sendTag, S *recvBuf, int recvCount, int source, int recvTag, MPI_Comm comm, MPI_Status *status)</td></tr>
<tr class="separator:a9560aba78fafcbed70d9c7a87426521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8838f131e33b78760928392ae026af45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8838f131e33b78760928392ae026af45"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a8838f131e33b78760928392ae026af45">mpi_sum</a> (const T t, MPI_Comm comm)</td></tr>
<tr class="separator:a8838f131e33b78760928392ae026af45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb714a90c5cf391b0c37baa804644c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63eb714a90c5cf391b0c37baa804644c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a63eb714a90c5cf391b0c37baa804644c">Par_bitonic_merge_incr</a> (std::vector&lt; T &gt; &amp;local_list, int proc_set_size, MPI_Comm comm)</td></tr>
<tr class="separator:a63eb714a90c5cf391b0c37baa804644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5681739fc044d4774f199186027bc82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5681739fc044d4774f199186027bc82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#aa5681739fc044d4774f199186027bc82">Par_bitonic_sort_decr</a> (std::vector&lt; T &gt; &amp;local_list, int proc_set_size, MPI_Comm comm)</td></tr>
<tr class="separator:aa5681739fc044d4774f199186027bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e164ad279018147554138bbb8716c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88e164ad279018147554138bbb8716c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a88e164ad279018147554138bbb8716c6">Par_bitonic_sort_incr</a> (std::vector&lt; T &gt; &amp;local_list, int proc_set_size, MPI_Comm comm)</td></tr>
<tr class="separator:a88e164ad279018147554138bbb8716c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcff423f403e9bb0249b9a765607257"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebcff423f403e9bb0249b9a765607257"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#aebcff423f403e9bb0249b9a765607257">partitionW</a> (std::vector&lt; T &gt; &amp;vec, unsigned int(*getWeight)(const T *), MPI_Comm comm)</td></tr>
<tr class="memdesc:aebcff423f403e9bb0249b9a765607257"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel weighted partitioning function. In our implementation, we do not pose any restriction on the input or the number of processors. This function can be used with an odd number of processors as well. Some processors can pass an empty vector as input. The relative ordering of the elements is preserved.  <a href="#aebcff423f403e9bb0249b9a765607257">More...</a><br /></td></tr>
<tr class="separator:aebcff423f403e9bb0249b9a765607257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17619d37244f7b63eced0eb3637de1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad17619d37244f7b63eced0eb3637de1a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ad17619d37244f7b63eced0eb3637de1a">scatterValues</a> (const std::vector&lt; T &gt; &amp;in, std::vector&lt; T &gt; &amp;out, <a class="el" href="dendro_8h.html#aeb8d2b4b56d0729f526888084e3b718c">DendroIntL</a> outSz, MPI_Comm comm)</td></tr>
<tr class="memdesc:ad17619d37244f7b63eced0eb3637de1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-distributes a STL vector, preserving the relative ordering of the elements.  <a href="#ad17619d37244f7b63eced0eb3637de1a">More...</a><br /></td></tr>
<tr class="separator:ad17619d37244f7b63eced0eb3637de1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57163a1962976eea76eb168604e71fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae57163a1962976eea76eb168604e71fc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ae57163a1962976eea76eb168604e71fc">sendAll</a> (const std::vector&lt; T &gt; &amp;sdata, const std::vector&lt; int &gt; &amp;sdest, MPI_Comm comm)</td></tr>
<tr class="separator:ae57163a1962976eea76eb168604e71fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b318734f4601812061f0d11d40c3ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09b318734f4601812061f0d11d40c3ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a09b318734f4601812061f0d11d40c3ba">shift</a> (MPI_Comm comm, const T *srcLocal, size_t srcSizeLocal, <a class="el" href="dendro_8h.html#aeb8d2b4b56d0729f526888084e3b718c">DendroIntL</a> srcBeginGlobal, T *dstLocal, size_t dstSizeLocal, <a class="el" href="dendro_8h.html#aeb8d2b4b56d0729f526888084e3b718c">DendroIntL</a> dstBeginGlobal, int ndofs=1)</td></tr>
<tr class="separator:a09b318734f4601812061f0d11d40c3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43c92faf7ccef4963b7b5968e534800"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#ab43c92faf7ccef4963b7b5968e534800">splitComm2way</a> (bool iAmEmpty, MPI_Comm *new_comm, MPI_Comm orig_comm)</td></tr>
<tr class="memdesc:ab43c92faf7ccef4963b7b5968e534800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates in parallel. If the input is not sorted, sample sort will be called within the function to sort the vector and then duplicates will be removed.  <a href="#ab43c92faf7ccef4963b7b5968e534800">More...</a><br /></td></tr>
<tr class="separator:ab43c92faf7ccef4963b7b5968e534800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333660b86811a5b312e9cc2d6e2991a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#a333660b86811a5b312e9cc2d6e2991a3">splitComm2way</a> (const bool *isEmptyList, MPI_Comm *new_comm, MPI_Comm orig_comm)</td></tr>
<tr class="memdesc:a333660b86811a5b312e9cc2d6e2991a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a communication group into two depending on the values in isEmptyList. Both the groups are sorted in the ascending order of their ranks in the old comm. All processors must call this function with the same 'isEmptyList' array.  <a href="#a333660b86811a5b312e9cc2d6e2991a3">More...</a><br /></td></tr>
<tr class="separator:a333660b86811a5b312e9cc2d6e2991a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6e633d08c91c48b3ea470e07ebdc90"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#a7f6e633d08c91c48b3ea470e07ebdc90">splitCommBinary</a> (MPI_Comm orig_comm, MPI_Comm *new_comm)</td></tr>
<tr class="memdesc:a7f6e633d08c91c48b3ea470e07ebdc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a communication group into two, the first having a power of 2 number of processors and the other having the remainder. The first group is sorted in the ascending order of their ranks in the old comm and the second group is sorted in the descending order of their ranks in the old comm.  <a href="#a7f6e633d08c91c48b3ea470e07ebdc90">More...</a><br /></td></tr>
<tr class="separator:a7f6e633d08c91c48b3ea470e07ebdc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6208b60f6b6b60614b2c8e883d393d0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#ae6208b60f6b6b60614b2c8e883d393d0">splitCommBinaryNoFlip</a> (MPI_Comm orig_comm, MPI_Comm *new_comm)</td></tr>
<tr class="memdesc:ae6208b60f6b6b60614b2c8e883d393d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a communication group into two, the first having a power of 2 number of processors and the other having the remainder. Both the groups are sorted in the ascending order of their ranks in the old comm.  <a href="#ae6208b60f6b6b60614b2c8e883d393d0">More...</a><br /></td></tr>
<tr class="separator:ae6208b60f6b6b60614b2c8e883d393d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c30f45534c8b8a18c0918db069265c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#ae9c30f45534c8b8a18c0918db069265c">splitCommUsingSplittingRank</a> (int splittingRank, MPI_Comm *new_comm, MPI_Comm orig_comm)</td></tr>
<tr class="separator:ae9c30f45534c8b8a18c0918db069265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c96b320c1ce7bb5c15b99f9b24e9d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#af5c96b320c1ce7bb5c15b99f9b24e9d8">waitForDebugger</a> (MPI_Comm comm, int commRank)</td></tr>
<tr class="memdesc:af5c96b320c1ce7bb5c15b99f9b24e9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for using gdb + mpi, based on notes by Tom Fogal.  <a href="#af5c96b320c1ce7bb5c15b99f9b24e9d8">More...</a><br /></td></tr>
<tr class="separator:af5c96b320c1ce7bb5c15b99f9b24e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aab84d6188ffa8bb3492ba62f0b72941c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#aab84d6188ffa8bb3492ba62f0b72941c">DBG_nProc</a></td></tr>
<tr class="separator:aab84d6188ffa8bb3492ba62f0b72941c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a920cfa7849c90b0c4e53545327c86d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html#a0a920cfa7849c90b0c4e53545327c86d">DBG_rProc</a></td></tr>
<tr class="separator:a0a920cfa7849c90b0c4e53545327c86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of Generic Parallel Functions: Sorting, Partitioning, Searching,... </p>
<dl class="section author"><dt>Author</dt><dd>Masado Ishii </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022-02-17</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Rahul Sampath </dd>
<dd>
Hari Sundar </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a41724fba006b22060f83b15d96e81e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41724fba006b22060f83b15d96e81e5b">&#9670;&nbsp;</a></span>bitonicSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::bitonicSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of parallel bitonic sort that does not expect the number of processors to be a power of 2. In fact, the number of processors can even be odd. Moreover, we do not even expect the length of the vector (neither locally nor globally) to be a power of 2 or even. Moreover, each processor can call this with a different number of elements. However, we do expect that 'in' atleast has 1 element on each processor. This recursively calls the function bitonicSort_binary, followed by a special parallel merge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the vector to be sorted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacepar.html#a0e3992a13172d29616c6d877d283178c" title="An implementation of parallel bitonic sort that expects the number of processors to be a power of 2...">bitonicSort_binary</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a0e3992a13172d29616c6d877d283178c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3992a13172d29616c6d877d283178c">&#9670;&nbsp;</a></span>bitonicSort_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::bitonicSort_binary </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of parallel bitonic sort that expects the number of processors to be a power of 2. However, unlike most implementations, we do not expect the length of the vector (neither locally nor globally) to be a power of 2 or even. Moreover, each processor can call this with a different number of elements. However, we do expect that 'in' atleast has 1 element on each processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the vector to be sorted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="aba9704922999ccde4fbc76e7ee92d2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9704922999ccde4fbc76e7ee92d2df">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::concatenate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>listA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>listB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parallel concatenation function. listB is appended (globally) to listA and the result is stored in listA. An useful application of this function is when listA and listB are individually sorted (globally) and the smallest element in listB is greater than the largest element in listA and we want to create a merged list that is sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listA</td><td>a distributed vector, the result is stored in listA </td></tr>
    <tr><td class="paramname">listB</td><td>another distributed vector that is appended to listA listA must not be empty on any of the calling processors. listB can be empty on some of the calling processors. listB will be cleared within the function. </td></tr>
    <tr><td class="paramname">comm</td><td>the communicator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Rahul Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a8cda730c20b5d40e582d81d5dd65ddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cda730c20b5d40e582d81d5dd65ddb2">&#9670;&nbsp;</a></span>dbg_printTNList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::dbg_printTNList </td>
          <td>(</td>
          <td class="paramtype">const TN *&#160;</td>
          <td class="paramname"><em>tnList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>listSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a distributed list of treeNodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tnList</td><td>Pointer to the list of treeNodes. </td></tr>
    <tr><td class="paramname">listSz</td><td>Size of the list. </td></tr>
    <tr><td class="paramname">lev</td><td>Level for printing. Set to 0 to print native levels. </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator to synchronize. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a82194ab32047be2e560e1fbcc8e76f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82194ab32047be2e560e1fbcc8e76f82">&#9670;&nbsp;</a></span>defaultWeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int par::defaultWeight </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a7e333399b7d956471926c9fad721ad73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e333399b7d956471926c9fad721ad73">&#9670;&nbsp;</a></span>loadImbalance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WeightT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double par::loadImbalance </td>
          <td>(</td>
          <td class="paramtype">WeightT&#160;</td>
          <td class="paramname"><em>localWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a9131e559b4020008f287cd0674c8904b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9131e559b4020008f287cd0674c8904b">&#9670;&nbsp;</a></span>maxLowerBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::maxLowerBound </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>searchList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parallel search function. </p>
<dl class="section author"><dt>Author</dt><dd>Rahul Sampath </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>locally sorted unique list of keys </td></tr>
    <tr><td class="paramname">searchList</td><td>globally sorted unique list. No processor must call this function with an empty list. </td></tr>
    <tr><td class="paramname">results</td><td>maximum lower bound in searchList for the corresponding key </td></tr>
    <tr><td class="paramname">comm</td><td>MPI communicator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int errorcode </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="ae3b8391c3ddda3ceea327c8f4df32b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b8391c3ddda3ceea327c8f4df32b0e">&#9670;&nbsp;</a></span>MergeLists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::MergeLists </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>listA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>listB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>KEEP_WHAT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges lists A, and B, retaining either the low or the High in list A. </p>
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listA</td><td>Input list, and where the output is stored. </td></tr>
    <tr><td class="paramname">listB</td><td>Second input list. </td></tr>
    <tr><td class="paramname">KEEP_WHAT</td><td>determines whether to retain the High or the low values from A and B. One of KEEP_HIGH or KEEP_LOW.</td></tr>
  </table>
  </dd>
</dl>
<p>Merging the two lists when their sizes are not the same is a bit involved. The major condition that needs to be used is that all elements that are less than max(min(A), min(B)) are retained by the KEEP_LOW processor, and similarly all elements that are larger larger than min(max(A), max(B)) are retained by the KEEP_HIGH processor.</p>
<p>The reason for this is that, on the Keep_Low side,</p>
<p>max(min(A), min(B)) &gt; min(A) &gt; max(A-)</p>
<p>and similarly on the Keep_high side,</p>
<p>min(max(A), max(B)) &lt; max(A) &lt; min(A+)</p>
<p>which guarantees that the merged lists remain bitonic. </p>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="abad721e799fda8d9b03f005c82dfd907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad721e799fda8d9b03f005c82dfd907">&#9670;&nbsp;</a></span>MergeSplit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::MergeSplit </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main operation in the parallel bitonic sort algorithm. This implements the compare-split operation. </p>
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which_keys</td><td>is one of KEEP_HIGH or KEEP_LOW </td></tr>
    <tr><td class="paramname">partner</td><td>is the processor with which to Merge and Split. </td></tr>
    <tr><td class="paramname">local_list</td><td>the input vector </td></tr>
    <tr><td class="paramname">comm</td><td>the communicator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a3f912a1ec8cfe795a15bfd1eb0f17aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f912a1ec8cfe795a15bfd1eb0f17aea">&#9670;&nbsp;</a></span>Mpi_Allgather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Allgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a507451ffddae0c35a435a482ee90e2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507451ffddae0c35a435a482ee90e2b9">&#9670;&nbsp;</a></span>Mpi_Allgatherv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recvcounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>displs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a6f36f5f0f402192cafe7abd2e79e2cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f36f5f0f402192cafe7abd2e79e2cc2">&#9670;&nbsp;</a></span>Mpi_Allreduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Allreduce </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="octUtils_8h_source.html#l00806">ot::checkSiblingLeafsTogether()</a>, <a class="el" href="octUtils_8h_source.html#l01249">ot::checksum_octree()</a>, <a class="el" href="octUtils_8h_source.html#l00293">ot::function2Octree()</a>, <a class="el" href="parUtils_8h_source.html#l00829">Mpi_AllreduceMinMeanMax()</a>, <a class="el" href="parUtils_8h_source.html#l00358">mpi_and()</a>, <a class="el" href="parUtils_8h_source.html#l00383">mpi_max()</a>, <a class="el" href="parUtils_8h_source.html#l00376">mpi_min()</a>, <a class="el" href="parUtils_8h_source.html#l00367">mpi_or()</a>, <a class="el" href="parUtils_8h_source.html#l00350">mpi_sum()</a>, and <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a4031931ac4952c894915988f03fae856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4031931ac4952c894915988f03fae856">&#9670;&nbsp;</a></span>Mpi_AllreduceMinMeanMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpar_1_1MinMeanMax.html">MinMeanMax</a>&lt;T&gt; par::Mpi_AllreduceMinMeanMax </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>localData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parUtils_8h_source.html#l00829">829</a> of file <a class="el" href="parUtils_8h_source.html">parUtils.h</a>.</p>

<p class="reference">References <a class="el" href="parUtils_8h_source.html#l00799">par::MinMeanMax&lt; T &gt;::m_glob_max</a>, <a class="el" href="parUtils_8h_source.html#l00798">par::MinMeanMax&lt; T &gt;::m_glob_mean</a>, <a class="el" href="parUtils_8h_source.html#l00797">par::MinMeanMax&lt; T &gt;::m_glob_min</a>, and <a class="el" href="namespacepar.html#a6f36f5f0f402192cafe7abd2e79e2cc2">Mpi_Allreduce()</a>.</p>

</div>
</div>
<a id="a16250c7602442c07706b8fb34498b3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16250c7602442c07706b8fb34498b3b7">&#9670;&nbsp;</a></span>Mpi_Alltoall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00383">mpi_max()</a>.</p>

</div>
</div>
<a id="acf98403458c01596773f87f1624340c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf98403458c01596773f87f1624340c7">&#9670;&nbsp;</a></span>Mpi_Alltoallv_dense()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Alltoallv_dense </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sendcnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sdispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recvcnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rdispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="af4a9666e020c2834f893b1a74e924853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a9666e020c2834f893b1a74e924853">&#9670;&nbsp;</a></span>Mpi_Alltoallv_Kway()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Alltoallv_Kway </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sbuff_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>s_cnt_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sdisp_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rbuff_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>r_cnt_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rdisp_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a0e372a8c8f3327c9bd0c9bb57a4ecbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e372a8c8f3327c9bd0c9bb57a4ecbb8">&#9670;&nbsp;</a></span>Mpi_Alltoallv_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Alltoallv_sparse </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sendcnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sdispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recvcnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rdispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a678d79b3e398b5c7a57ff433d5fe134d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678d79b3e398b5c7a57ff433d5fe134d">&#9670;&nbsp;</a></span>mpi_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T par::mpi_and </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parUtils_8h_source.html#l00358">358</a> of file <a class="el" href="parUtils_8h_source.html">parUtils.h</a>.</p>

<p class="reference">References <a class="el" href="namespacepar.html#a6f36f5f0f402192cafe7abd2e79e2cc2">Mpi_Allreduce()</a>.</p>

</div>
</div>
<a id="ac07e7526826fd6076368389596162ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07e7526826fd6076368389596162ce5">&#9670;&nbsp;</a></span>Mpi_Bcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Bcast </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="octUtils_8h_source.html#l00293">ot::function2Octree()</a>, and <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a665c131431ad9b6bf575964bd0d1e0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665c131431ad9b6bf575964bd0d1e0cb">&#9670;&nbsp;</a></span>mpi_comm_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int par::mpi_comm_rank </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="acc6f2d8ab68d4aa4a5297b76bdd888a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6f2d8ab68d4aa4a5297b76bdd888a1">&#9670;&nbsp;</a></span>mpi_comm_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int par::mpi_comm_size </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="abf969002e58145bf248fdb2c39ce2611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf969002e58145bf248fdb2c39ce2611">&#9670;&nbsp;</a></span>Mpi_Exscan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Exscan </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="ab353e117ed61668e26eee1f171867833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab353e117ed61668e26eee1f171867833">&#9670;&nbsp;</a></span>Mpi_Gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a3e7d08734a05f1c5f64fb39d9d394963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7d08734a05f1c5f64fb39d9d394963">&#9670;&nbsp;</a></span>Mpi_Iallgather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Iallgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Masado Ishii </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00383">mpi_max()</a>.</p>

</div>
</div>
<a id="a98437044ff27973fd3e52a3a78cbb971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98437044ff27973fd3e52a3a78cbb971">&#9670;&nbsp;</a></span>Mpi_Imrecv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Imrecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Message *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a5323d9cac38e61044e1cca337400e683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5323d9cac38e61044e1cca337400e683">&#9670;&nbsp;</a></span>Mpi_Irecv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Irecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="aa3973b507fce9b48f74acec8f40767bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3973b507fce9b48f74acec8f40767bb">&#9670;&nbsp;</a></span>Mpi_Isend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Isend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>, <a class="el" href="p2p_8h_source.html#l00108">par::P2PScalar&lt; ScalarT, LEN &gt;::send()</a>, and <a class="el" href="p2p_8h_source.html#l00163">par::P2PVector&lt; X &gt;::send()</a>.</p>

</div>
</div>
<a id="ab31372a4e3b8df9afddf2e423a367b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31372a4e3b8df9afddf2e423a367b9c">&#9670;&nbsp;</a></span>Mpi_Issend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Issend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a11a2e5f9178eada3ec45f3eb8603abe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a2e5f9178eada3ec45f3eb8603abe7">&#9670;&nbsp;</a></span>mpi_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T par::mpi_max </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parUtils_8h_source.html#l00383">383</a> of file <a class="el" href="parUtils_8h_source.html">parUtils.h</a>.</p>

<p class="reference">References <a class="el" href="namespacepar.html#a6f36f5f0f402192cafe7abd2e79e2cc2">Mpi_Allreduce()</a>, <a class="el" href="namespacepar.html#a16250c7602442c07706b8fb34498b3b7">Mpi_Alltoall()</a>, <a class="el" href="namespacepar.html#a3e7d08734a05f1c5f64fb39d9d394963">Mpi_Iallgather()</a>, <a class="el" href="namespacepar.html#a1e56743243a5b6ef54e73b4f8a0e7f02">Mpi_NBX()</a>, <a class="el" href="namespacepar.html#ad99b29e94b39dcf1f38a93c1eaed2187">Mpi_NBX_neighbors()</a>, and <a class="el" href="namespacepar.html#affec3e38b8dbe9de3614e84eba6d6875">Mpi_NBX_sizes()</a>.</p>

</div>
</div>
<a id="a4f89f090934876e7226b7cc29f66dbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f89f090934876e7226b7cc29f66dbe1">&#9670;&nbsp;</a></span>mpi_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T par::mpi_min </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parUtils_8h_source.html#l00376">376</a> of file <a class="el" href="parUtils_8h_source.html">parUtils.h</a>.</p>

<p class="reference">References <a class="el" href="namespacepar.html#a6f36f5f0f402192cafe7abd2e79e2cc2">Mpi_Allreduce()</a>.</p>

</div>
</div>
<a id="a7b5c0c242ec0d019eb00df530d845ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5c0c242ec0d019eb00df530d845ec7">&#9670;&nbsp;</a></span>Mpi_Mrecv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Mrecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Message *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a1e56743243a5b6ef54e73b4f8a0e7f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e56743243a5b6ef54e73b4f8a0e7f02">&#9670;&nbsp;</a></span>Mpi_NBX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_NBX </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_sources</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nonblocking Consensus due to (Hoefler et al., 2010). </p>
<dl class="section author"><dt>Author</dt><dd>Masado Ishii </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>, and <a class="el" href="parUtils_8h_source.html#l00383">mpi_max()</a>.</p>

</div>
</div>
<a id="a9553e0613b4aebf96a2665a8446ae945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9553e0613b4aebf96a2665a8446ae945">&#9670;&nbsp;</a></span>Mpi_NBX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_NBX </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a>&#160;</td>
          <td class="paramname"><em>synch_p2p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a>&#160;</td>
          <td class="paramname"><em>synch_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_sources</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad99b29e94b39dcf1f38a93c1eaed2187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99b29e94b39dcf1f38a93c1eaed2187">&#9670;&nbsp;</a></span>Mpi_NBX_neighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_NBX_neighbors </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_sources</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nonblocking Consensus due to (Hoefler et al., 2010). Allows sparse alltoall exchange without calling any alltoall. A barrier is automatically called for correctness. For better control over when the barrier must complete, supply MPI_Request(s) to the appropriate overloads. </p>
<dl class="section author"><dt>Author</dt><dd>Masado Ishii </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>, and <a class="el" href="parUtils_8h_source.html#l00383">mpi_max()</a>.</p>

</div>
</div>
<a id="a21210a95971718fe1711c62fc8fb803a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21210a95971718fe1711c62fc8fb803a">&#9670;&nbsp;</a></span>Mpi_NBX_neighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_NBX_neighbors </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a>&#160;</td>
          <td class="paramname"><em>synch_p2p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a>&#160;</td>
          <td class="paramname"><em>synch_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_sources</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nonblocking Consensus due to (Hoefler et al., 2010). Allows sparse alltoall exchange without calling any alltoall. However, a non-blocking synch is needed before sending again, due to implementation of nbx with MPI_ANY_SOURCE. Must call MPI_Waitall() with synch_p2p[] before sending to destinations. Must call MPI_Wait() with synch_global before sending to others. After synch_global completes, synch_p2p[] is not needed, so synch_p2p=nullptr is ok if no middle phase for destinations only. </p>
<dl class="section author"><dt>Author</dt><dd>Masado Ishii </dd></dl>

</div>
</div>
<a id="affec3e38b8dbe9de3614e84eba6d6875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affec3e38b8dbe9de3614e84eba6d6875">&#9670;&nbsp;</a></span>Mpi_NBX_sizes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_NBX_sizes </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>send_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>recv_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_sources</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nonblocking Consensus due to (Hoefler et al., 2010). </p>
<dl class="section author"><dt>Author</dt><dd>Masado Ishii </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>, and <a class="el" href="parUtils_8h_source.html#l00383">mpi_max()</a>.</p>

</div>
</div>
<a id="a69d93ad609b8664db3eb1b837c9377d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d93ad609b8664db3eb1b837c9377d2">&#9670;&nbsp;</a></span>Mpi_NBX_sizes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_NBX_sizes </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>destinations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>send_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>recv_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a>&#160;</td>
          <td class="paramname"><em>synch_p2p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpar_1_1NbxSynch.html">NbxSynch</a>&#160;</td>
          <td class="paramname"><em>synch_global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_sources</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd77f62a8e69686746a0881deeb58f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd77f62a8e69686746a0881deeb58f50">&#9670;&nbsp;</a></span>mpi_next_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, int&gt; par::mpi_next_if </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>included</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ranks of nonempty predecessor and successor without comm split. </p>
<p><a class="el" href="namespacepar.html#abd77f62a8e69686746a0881deeb58f50" title="Get ranks of nonempty predecessor and successor without comm split. ">mpi_next_if()</a> </p><dl class="section author"><dt>Author</dt><dd>Masado Ishii </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022-03-23 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Rank of {predecessor, successor} or MPI_PROC_NULL </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a82e4851a298231bc0f8a9f0c8e6aa615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e4851a298231bc0f8a9f0c8e6aa615">&#9670;&nbsp;</a></span>mpi_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T par::mpi_or </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parUtils_8h_source.html#l00367">367</a> of file <a class="el" href="parUtils_8h_source.html">parUtils.h</a>.</p>

<p class="reference">References <a class="el" href="namespacepar.html#a6f36f5f0f402192cafe7abd2e79e2cc2">Mpi_Allreduce()</a>.</p>

</div>
</div>
<a id="a27df4c5d5f15c007e2cf7a6cad6a9c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27df4c5d5f15c007e2cf7a6cad6a9c37">&#9670;&nbsp;</a></span>Mpi_Recv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Recv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="p2p_8h_source.html#l00167">par::P2PVector&lt; X &gt;::recv()</a>, <a class="el" href="p2p_8h_source.html#l00120">par::P2PScalar&lt; ScalarT, LEN &gt;::recv_all()</a>, and <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a8a5e460961f44d284ec870ea19c88766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5e460961f44d284ec870ea19c88766">&#9670;&nbsp;</a></span>Mpi_Reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Reduce </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00803">Mpi_ReduceMinMeanMax()</a>, and <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="ac19fcde5a62c75d7a63d3b631301ddcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19fcde5a62c75d7a63d3b631301ddcd">&#9670;&nbsp;</a></span>Mpi_ReduceMinMeanMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpar_1_1MinMeanMax.html">MinMeanMax</a>&lt;T&gt; par::Mpi_ReduceMinMeanMax </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>localData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parUtils_8h_source.html#l00803">803</a> of file <a class="el" href="parUtils_8h_source.html">parUtils.h</a>.</p>

<p class="reference">References <a class="el" href="parUtils_8h_source.html#l00799">par::MinMeanMax&lt; T &gt;::m_glob_max</a>, <a class="el" href="parUtils_8h_source.html#l00798">par::MinMeanMax&lt; T &gt;::m_glob_mean</a>, <a class="el" href="parUtils_8h_source.html#l00797">par::MinMeanMax&lt; T &gt;::m_glob_min</a>, and <a class="el" href="namespacepar.html#a8a5e460961f44d284ec870ea19c88766">Mpi_Reduce()</a>.</p>

</div>
</div>
<a id="ae7394dbde57f4738b4f903f3469cd074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7394dbde57f4738b4f903f3469cd074">&#9670;&nbsp;</a></span>Mpi_Scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Scan </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Op&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="octUtils_8h_source.html#l01079">ot::quadTreeToGnuplot()</a>, and <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a9560aba78fafcbed70d9c7a87426521c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9560aba78fafcbed70d9c7a87426521c">&#9670;&nbsp;</a></span>Mpi_Sendrecv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::Mpi_Sendrecv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>recvBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recvCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recvTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00277">par::SendRecvSchedule::resize()</a>.</p>

</div>
</div>
<a id="a8838f131e33b78760928392ae026af45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8838f131e33b78760928392ae026af45">&#9670;&nbsp;</a></span>mpi_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T par::mpi_sum </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parUtils_8h_source.html#l00350">350</a> of file <a class="el" href="parUtils_8h_source.html">parUtils.h</a>.</p>

<p class="reference">References <a class="el" href="namespacepar.html#a6f36f5f0f402192cafe7abd2e79e2cc2">Mpi_Allreduce()</a>.</p>

</div>
</div>
<a id="a63eb714a90c5cf391b0c37baa804644c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eb714a90c5cf391b0c37baa804644c">&#9670;&nbsp;</a></span>Par_bitonic_merge_incr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::Par_bitonic_merge_incr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proc_set_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="aa5681739fc044d4774f199186027bc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5681739fc044d4774f199186027bc82">&#9670;&nbsp;</a></span>Par_bitonic_sort_decr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::Par_bitonic_sort_decr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proc_set_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a88e164ad279018147554138bbb8716c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e164ad279018147554138bbb8716c6">&#9670;&nbsp;</a></span>Par_bitonic_sort_incr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::Par_bitonic_sort_incr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proc_set_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="aebcff423f403e9bb0249b9a765607257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcff423f403e9bb0249b9a765607257">&#9670;&nbsp;</a></span>partitionW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::partitionW </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int(*)(const T *)&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A parallel weighted partitioning function. In our implementation, we do not pose any restriction on the input or the number of processors. This function can be used with an odd number of processors as well. Some processors can pass an empty vector as input. The relative ordering of the elements is preserved. </p>
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd>
<dd>
Rahul Sampath </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the input vector </td></tr>
    <tr><td class="paramname">getWeight</td><td>function pointer to compute the weight of each element. If you pass NULL, then every element will get a weight equal to 1. </td></tr>
    <tr><td class="paramname">comm</td><td>the communicator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="ad17619d37244f7b63eced0eb3637de1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17619d37244f7b63eced0eb3637de1a">&#9670;&nbsp;</a></span>scatterValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int par::scatterValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dendro_8h.html#aeb8d2b4b56d0729f526888084e3b718c">DendroIntL</a>&#160;</td>
          <td class="paramname"><em>outSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-distributes a STL vector, preserving the relative ordering of the elements. </p>
<dl class="section author"><dt>Author</dt><dd>Rahul S. Sampath </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input vector </td></tr>
    <tr><td class="paramname">out</td><td>The output vector. Memory for this vector will be allocated within the function. </td></tr>
    <tr><td class="paramname">outSz</td><td>The local size of the output vector on the calling processor. </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error flag </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="ae57163a1962976eea76eb168604e71fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57163a1962976eea76eb168604e71fc">&#9670;&nbsp;</a></span>sendAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; par::sendAll </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sdest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a09b318734f4601812061f0d11d40c3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b318734f4601812061f0d11d40c3ba">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void par::shift </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>srcLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>srcSizeLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dendro_8h.html#aeb8d2b4b56d0729f526888084e3b718c">DendroIntL</a>&#160;</td>
          <td class="paramname"><em>srcBeginGlobal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dstLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstSizeLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dendro_8h.html#aeb8d2b4b56d0729f526888084e3b718c">DendroIntL</a>&#160;</td>
          <td class="paramname"><em>dstBeginGlobal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndofs</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="tnUtils_8h_source.html#l00126">ot::dbgCoordStr()</a>, <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>, <a class="el" href="binUtils_8h_source.html#l00238">binOp::reflectHyperplane()</a>, and <a class="el" href="binUtils_8h_source.html#l00209">binOp::selectHyperplanes()</a>.</p>

</div>
</div>
<a id="ab43c92faf7ccef4963b7b5968e534800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43c92faf7ccef4963b7b5968e534800">&#9670;&nbsp;</a></span>splitComm2way() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int par::splitComm2way </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>iAmEmpty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *&#160;</td>
          <td class="paramname"><em>new_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>orig_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes duplicates in parallel. If the input is not sorted, sample sort will be called within the function to sort the vector and then duplicates will be removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>the input vector. </td></tr>
    <tr><td class="paramname">isSorted</td><td>pass 'true' if the vector is globally sorted. </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Rahul Sampath Splits a communication group into two, one containing processors that passed a value of 'false' for the parameter 'iAmEmpty' and the another containing processors that passed a value of 'true' for the parameter. Both the groups are sorted in the ascending order of their ranks in the old comm. </dd>
<dd>
Rahul Sampath </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iAmEmpty</td><td>Some flag to determine which group the calling processor will be combined into. </td></tr>
    <tr><td class="paramname">orig_comm</td><td>The comm group that needs to be split. </td></tr>
    <tr><td class="paramname">new_comm</td><td>The new comm group. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="a333660b86811a5b312e9cc2d6e2991a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333660b86811a5b312e9cc2d6e2991a3">&#9670;&nbsp;</a></span>splitComm2way() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int par::splitComm2way </td>
          <td>(</td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>isEmptyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *&#160;</td>
          <td class="paramname"><em>new_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>orig_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a communication group into two depending on the values in isEmptyList. Both the groups are sorted in the ascending order of their ranks in the old comm. All processors must call this function with the same 'isEmptyList' array. </p>
<dl class="section author"><dt>Author</dt><dd>Rahul Sampath </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isEmptyList</td><td>flags (of length equal to the number of processors) to determine whether each processor is active or not. </td></tr>
    <tr><td class="paramname">orig_comm</td><td>The comm group that needs to be split. </td></tr>
    <tr><td class="paramname">new_comm</td><td>The new comm group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f6e633d08c91c48b3ea470e07ebdc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6e633d08c91c48b3ea470e07ebdc90">&#9670;&nbsp;</a></span>splitCommBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int par::splitCommBinary </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>orig_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *&#160;</td>
          <td class="paramname"><em>new_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a communication group into two, the first having a power of 2 number of processors and the other having the remainder. The first group is sorted in the ascending order of their ranks in the old comm and the second group is sorted in the descending order of their ranks in the old comm. </p>
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_comm</td><td>The comm group that needs to be split. </td></tr>
    <tr><td class="paramname">new_comm</td><td>The new comm group. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="ae6208b60f6b6b60614b2c8e883d393d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6208b60f6b6b60614b2c8e883d393d0">&#9670;&nbsp;</a></span>splitCommBinaryNoFlip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int par::splitCommBinaryNoFlip </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>orig_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *&#160;</td>
          <td class="paramname"><em>new_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a communication group into two, the first having a power of 2 number of processors and the other having the remainder. Both the groups are sorted in the ascending order of their ranks in the old comm. </p>
<dl class="section author"><dt>Author</dt><dd>Hari Sundar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_comm</td><td>The comm group that needs to be split. </td></tr>
    <tr><td class="paramname">new_comm</td><td>The new comm group. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="ae9c30f45534c8b8a18c0918db069265c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c30f45534c8b8a18c0918db069265c">&#9670;&nbsp;</a></span>splitCommUsingSplittingRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int par::splitCommUsingSplittingRank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splittingRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm *&#160;</td>
          <td class="paramname"><em>new_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>orig_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<a id="af5c96b320c1ce7bb5c15b99f9b24e9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c96b320c1ce7bb5c15b99f9b24e9d8">&#9670;&nbsp;</a></span>waitForDebugger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void par::waitForDebugger </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>commRank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility for using gdb + mpi, based on notes by Tom Fogal. </p>
<p>Debugging MPI programs with the GNU debugger </p><dl class="section author"><dt>Author</dt><dd>Tom Fogal, University of Utah </dd>
<dd>
Masado Ishii </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2014-02-19  2019-10-30 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Building and running on Unix systems.  Add waitForDebugger(comm, rank) right after MPI_Init().  (If using mpich): mpirun -np 2 -env USE_MPI_DEBUGGER 1 ./my_program  pid=$(pgrep my_program | head -n 1) ; gdb -q -ex "attach ${pid}" -ex "set variable goAhead=1" -ex "finish" </dd></dl>

<p class="reference">Referenced by <a class="el" href="parUtils_8h_source.html#l00446">par::NbxSynch::disable()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aab84d6188ffa8bb3492ba62f0b72941c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab84d6188ffa8bb3492ba62f0b72941c">&#9670;&nbsp;</a></span>DBG_nProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int par::DBG_nProc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a920cfa7849c90b0c4e53545327c86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a920cfa7849c90b0c4e53545327c86d">&#9670;&nbsp;</a></span>DBG_rProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int par::DBG_rProc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
